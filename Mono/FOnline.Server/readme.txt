- change delegates naming from EventXXXHandler to XXXHandler???
- correct underlying types for enums
- foreach calls ScriptArray::Length every iter, but during foreach collectoin should be blocked. optimize
- every function that accepts reference to array and return its size allows null arrays and passes 0 pointer further. Might not be the case always, if native function does not accept null, it's better to throw exception in managed world (it would be thrown on .ThisPtr access)
- default values for arguments?
- in case of null deref, is managed exception thrown? seems like native likes to crash in that case

- Wrappers sometimes use cr.ThisPtr and sometimes (IntPtr)cr. What's the difference?
if cr is null in first case, we get managed exception (really? not sure about that), wheras if cr is null in second case, we pass 0 pointer and let the engine handle it.
I'm not sure if first case is actually THAT useful, but for now it's this way.

- long RefCount

!!! handlers should not return value...it's done by e handlerarg

- enum vs static readonly fields: 
  - static fields can be extended by deriving from given class, it would be important
    if we would provide all core functionality in compiled lib. in case we provide full source, well, whatever fits
  - enums are useful for methods where you need to directly state the value (Say(Say.NetMsg... for example)
  - enums are troublesome for autogenerated fields (fields will remain as primitive types probably)

- signed/unsigned time events, this mean our bind parse has to recognize params and not only param counts...

- GlobalInvite event args etc, not as useful because of ref passing

- redo the way global properties are handled (just use the fact mono is initialized after AS an we can fetch the offsets and pointers).